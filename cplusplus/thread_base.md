# Multithread

## Summary

1. 计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程, 线程是cpu调度分配的最小单位), 由于超线程技术, 实际上可以并行的线程数量通常是物理核数的两倍, 这也是操作系统看到的核数.我们只care可以并行的线程数量, 所以之后所说的核数是操作系统看到的核数, 所指的核也是超线程技术之后的那个核(不是物理核).
2. **进程是操作系统资源分配(内存, 显卡, 磁盘)的最小单位, 线程是执行调度(即cpu调度)的最小单位(cpu看到的都是线程而不是进程)**, 一个进程可以有一个或多个线程, 线程之间共享进程的资源, 通过这样的范式, 就可以减少进程的创建和销毁带来的代价, 可以让进程少一点, 保持相对稳定, 不断去调度线程就好.如果计算机有多个cpu核, 且计算机中的总的线程数量小于核数, 那线程就可以并行运行在不同的核中, 如果是单核多线程, 那多线程之间就不是并行, 而是并发, 即为了均衡负载, cpu调度器会不断的在单核上切换不同的线程执行, 但是我们说过, 一个核只能运行一个线程, 所以并发虽然让我们看起来不同线程之间的任务是并行执行的, 但是实际上却由于增加了线程切换的开销使得代价更大了.如果是多核多线程, 且线程数量大于核数, 其中有些线程就会不断切换, 并发执行, 但实际上最大的并行数量还是当前这个进程中的核的数量, 所以盲目增加线程数不仅不会让你的程序更快, 反而会给你的程序增加额外的开销.
3. 任务可以分为计算密集型和IO密集型, 假设我们现在使用一个进程来完成这个任务, 对计算密集型任务, 可以使用【核心数】个线程, 就可以占满cpu资源, 进而可以充分利用cpu, 如果再多, 就会造成额外的开销；对于IO密集型任务(涉及到网络、磁盘IO的任务都是IO密集型任务), 线程由于被IO阻塞, 如果仍然用【核心数】个线程, cpu是跑不满的, 于是可以使用更多个线程来提高cpu使用率.
4. 实现并行计算有三种方式, 多线程, 多进程, 多进程+多线程.如果是多进程, 因为每个**进程资源是独立的(地址空间和数据空间), 就要在操作系统层面进行通信, 如管道, 队列, 信号等**; **多线程的话会共享进程中的地址空间和数据空间**, 一个线程的数据可以直接提供给其他线程使用, 但方便的同时会造成变量值的混乱, 所以要通过线程锁来限制线程的执行其他语言, CPU是多核时是支持多个线程同时执行.

## Concept

* process: 进程, 系统资源分配(内存, 显卡, 磁盘)的最小单位
* thread: 执行调度(即cpu调度)的最小单位


<!-- 
fixme: 填补此处详细内容
线程间共享:

* 进程的内存, 显卡, 磁盘等资源

线程间不共享:

* 栈 -->

## Thread communication

## Reference
